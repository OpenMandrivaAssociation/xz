From 473b4b496eb07802e4126640275544615bfb002c Mon Sep 17 00:00:00 2001
From: Lasse Collin <lasse.collin@tukaani.org>
Date: Thu, 1 Dec 2022 20:04:17 +0200
Subject: [PATCH] liblzma: Use __has_attribute(__symver__) to fix Clang
 detection.

If someone sets up Clang to define __GNUC__ to 10 or greater
then symvers broke. __has_attribute is supported by such GCC
and Clang versions that don't support __symver__ so this should
be much better and simpler way to detect if __symver__ is
actually supported.

Thanks to Tomasz Gajc for the bug report.
---
 src/liblzma/common/common.h | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/src/liblzma/common/common.h b/src/liblzma/common/common.h
index 01841de..b4855c0 100644
--- a/src/liblzma/common/common.h
+++ b/src/liblzma/common/common.h
@@ -63,7 +63,12 @@
 // since 2000). When using @@ instead of @@@, the internal name must not be
 // the same as the external name to avoid problems in some situations. This
 // is why "#define foo_52 foo" is needed for the default symbol versions.
-#	if TUKLIB_GNUC_REQ(10, 0) && !defined(__INTEL_COMPILER)
+//
+// __has_attribute is supported before GCC 10 and it is supported in Clang 14
+// too (which doesn't support __symver__) so use it to detect if __symver__
+// is available. This should be far more reliable than looking at compiler
+// version macros as nowadays especially __GNUC__ is defined by many compilers.
+#	if defined(__has_attribute) && __has_attribute(__symver__)
 #		define LZMA_SYMVER_API(extnamever, type, intname) \
 			extern __attribute__((__symver__(extnamever))) \
 					LZMA_API(type) intname
-- 
2.38.1

